"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tx_1 = require("@ethereumjs/tx");
const ethereumjs_util_1 = require("ethereumjs-util");
const Utils_1 = require("@opengsn/common/dist/Utils");
class RelayedTransactionValidator {
    constructor(contractInteractor, logger, config) {
        this.contractInteractor = contractInteractor;
        this.config = config;
        this.logger = logger;
    }
    /**
     * Decode the signed transaction returned from the Relay Server, compare it to the
     * requested transaction and validate its signature.
     * @returns a signed {@link Transaction} instance for broadcasting, or null if returned
     * transaction is not valid.
     */
    validateRelayResponse(request, maxAcceptanceBudget, returnedTx) {
        const tx = tx_1.Transaction.fromSerializedTx(ethereumjs_util_1.toBuffer(returnedTx), this.contractInteractor.getRawTxOptions());
        const transaction = Object.assign({ signer: tx.getSenderAddress().toString() }, tx.toJSON());
        if (transaction.to == null) {
            throw new Error('transaction.to must be defined');
        }
        if (transaction.s == null || transaction.r == null || transaction.v == null) {
            throw new Error('tx signature must be defined');
        }
        this.logger.debug(`returnedTx: ${JSON.stringify(transaction, null, 2)}`);
        const signer = transaction.signer;
        const externalGasLimit = transaction.gasLimit;
        const relayRequestAbiEncode = this.contractInteractor.encodeABI(maxAcceptanceBudget, request.relayRequest, request.metadata.signature, request.metadata.approvalData, externalGasLimit);
        const relayHubAddress = this.contractInteractor.getDeployment().relayHubAddress;
        if (relayHubAddress == null) {
            throw new Error('no hub address');
        }
        if (Utils_1.isSameAddress(transaction.to, relayHubAddress) &&
            relayRequestAbiEncode === transaction.data &&
            Utils_1.isSameAddress(request.relayRequest.relayData.relayWorker, signer)) {
            this.logger.info('validateRelayResponse - valid transaction response');
            const receivedNonce = parseInt(transaction.nonce);
            if (receivedNonce > request.metadata.relayMaxNonce) {
                // TODO: need to validate that client retries the same request and doesn't double-spend.
                // Note that this transaction is totally valid from the EVM's point of view
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                throw new Error(`Relay used a tx nonce higher than requested. Requested ${request.metadata.relayMaxNonce} got ${receivedNonce}`);
            }
            return true;
        }
        else {
            console.error('validateRelayResponse: req', relayRequestAbiEncode, relayHubAddress, request.relayRequest.relayData.relayWorker);
            console.error('validateRelayResponse: rsp', transaction.data, transaction.to, signer);
            return false;
        }
    }
}
exports.RelayedTransactionValidator = RelayedTransactionValidator;
//# sourceMappingURL=RelayedTransactionValidator.js.map