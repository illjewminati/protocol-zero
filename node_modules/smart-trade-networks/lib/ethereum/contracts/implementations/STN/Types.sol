// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/Ownable.sol";

contract Types is Ownable {

    enum EipType {
        ERC721,
        ERC1155
    }

    struct NftType {
        address creator;
        address contractAddress;
        uint256 createdAt;
        bool isValid;
        string name;
        EipType eipType;
    }
    
    
    uint256 private price;
    uint256 private counter;
    address[] private contracts;
    mapping(uint256 => NftType) private typesByPosition;
    mapping(address => NftType) private typesByAddress;
     

    constructor (address _multisigWallet, uint256 _price) {
        require(_multisigWallet != address(0), "Multisig address cannot be 0");
        price = _price;
        transferOwnership(_multisigWallet);
    }

    function setPrice(uint256 _price) external onlyOwner {
         price = _price;
    } 

    function addType(string calldata _name, address _contractAddress, EipType _eipType) external onlyOwner {
        _addType(_name, _contractAddress, _eipType);
    }

    function changeTypeState(address _contractAddress, bool _isValid) external onlyOwner {
        require(_contractAddress != address(0), "Contracts Address cannot be 0");
        require(typesByAddress[_contractAddress].contractAddress == _contractAddress, "Contract is not yet created");
        typesByAddress[_contractAddress].isValid = _isValid;
    }

    function addTypePayable(string calldata _name, address _contractAddress, EipType _eipType) external payable {
        require(msg.value >= price);
        payable(owner()).transfer(price);
        if(msg.value > price) {
            uint256 valueBack = msg.value - price;
            payable(_msgSender()).transfer(valueBack);
        } 
        _addType(_name, _contractAddress, _eipType);
    }

    function _addType(string memory _name, address _contractAddress, EipType _eipType) private {
        require(_contractAddress != address(0), "Contracts Address cannot be 0");
        require(typesByAddress[_contractAddress].contractAddress == address(0), "Contract has already been added");
        
        contracts.push(_contractAddress);

        NftType memory newData = NftType({
            creator: _msgSender(),
            contractAddress: _contractAddress,
            createdAt: block.timestamp,
            isValid: true,
            name: _name,
            eipType: _eipType
        });

        typesByAddress[_contractAddress] = newData;
        typesByPosition[counter] = newData;
       
        counter += 1;
    }

    function getContracts() external view returns(address[] memory) {
        return contracts;
    }

    function getTypeByPosition(uint256 _pos) external view returns(NftType memory) {
        return typesByPosition[_pos];
    }

    function getTypeByAddress(address _contractAddress) external view returns(NftType memory) {
        return typesByAddress[_contractAddress];
    }

    function getNumberOfTypes() external view returns(uint256) {
        return counter;
    }


}