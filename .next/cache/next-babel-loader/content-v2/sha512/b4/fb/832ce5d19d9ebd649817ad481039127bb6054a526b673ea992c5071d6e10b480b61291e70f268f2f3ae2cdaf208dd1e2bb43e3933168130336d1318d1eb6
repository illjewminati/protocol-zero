{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UniswapDappSharedLogic = void 0;\n\nvar bignumber_js_1 = require(\"bignumber.js\");\n\nvar rxjs_1 = require(\"rxjs\");\n\nvar simple_uniswap_sdk_1 = require(\"simple-uniswap-sdk\");\n\nvar chain_1 = require(\"./chain\");\n\nvar coin_gecko_1 = require(\"./coin-gecko\");\n\nvar ethereum_provider_1 = require(\"./ethereum-provider\");\n\nvar models_1 = require(\"./models\");\n\nvar theming_1 = require(\"./theming\");\n\nvar token_1 = require(\"./token\");\n\nvar utils_1 = require(\"./utils\");\n\nvar UniswapDappSharedLogic =\n/** @class */\nfunction () {\n  function UniswapDappSharedLogic(_context) {\n    this._context = _context;\n    this.inputToken$ = new rxjs_1.Subject();\n    this.outputToken$ = new rxjs_1.Subject();\n    this.tradeContext$ = new rxjs_1.Subject();\n    this.newPriceTradeContext$ = new rxjs_1.Subject();\n    this.loading$ = new rxjs_1.BehaviorSubject(false);\n    this.supportedTokenBalances = [];\n    this.uniswapPairSettings = new simple_uniswap_sdk_1.UniswapPairSettings();\n    this.uniswapPairSettings$ = new rxjs_1.Subject();\n    this.selectorOpenFrom$ = new rxjs_1.Subject();\n    this.chainId$ = new rxjs_1.Subject();\n    this.supportedNetwork = false;\n    this.supportedNetwork$ = new rxjs_1.BehaviorSubject(false);\n    this.miningTransaction$ = new rxjs_1.BehaviorSubject(undefined);\n    this.tradeCompleted$ = new rxjs_1.BehaviorSubject(false);\n    this._confirmSwapOpened = false;\n    this._inputAmount = new bignumber_js_1.BigNumber('0');\n    this._quoteSubscription = simple_uniswap_sdk_1.UniswapSubscription.EMPTY; // services\n\n    this._ethereumProvider = new ethereum_provider_1.EthereumProvider(this._context.ethereumAddress, this._context.ethereumProvider);\n    this._coinGecko = new coin_gecko_1.CoinGecko();\n    this._theming = new theming_1.Theming(this._context.theming);\n    this._tokenService = new token_1.TokenService(this._ethereumProvider, this._context.supportedNetworkTokens);\n    this._chainService = new chain_1.ChainService(this._ethereumProvider);\n    this._blockStream = rxjs_1.Subscription.EMPTY;\n\n    if (this._context.settings) {\n      this.uniswapPairSettings = this._context.settings;\n    }\n\n    this.uniswapPairSettings$.next(this.uniswapPairSettings);\n  }\n  /**\r\n   * Init the shared logic\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.init = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var eth, supportedNetworkTokens, inputToken, _a, _c;\n\n      var _this = this;\n\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            this.loading$.next(true);\n            this.supportedNetwork = false;\n            this.supportedNetwork$.next(this.supportedNetwork);\n\n            this._quoteSubscription.unsubscribe();\n\n            this._blockStream.unsubscribe();\n\n            return [4\n            /*yield*/\n            , this.setupEthereumContext()];\n\n          case 1:\n            _d.sent();\n\n            if (!this.supportedNetwork) {\n              this.loading$.next(false);\n              return [2\n              /*return*/\n              ];\n            }\n\n            eth = simple_uniswap_sdk_1.ETH.info(this.chainId);\n            supportedNetworkTokens = this._context.supportedNetworkTokens.find(function (t) {\n              return t.chainId === _this.chainId;\n            });\n\n            if (supportedNetworkTokens.defaultInputValue && this._inputAmount.isZero()) {\n              this._inputAmount = new bignumber_js_1.BigNumber(supportedNetworkTokens.defaultInputValue);\n            }\n\n            if (!supportedNetworkTokens.supportedTokens.find(function (c) {\n              return c.contractAddress.toLowerCase() === eth.contractAddress.toLowerCase();\n            })) {\n              supportedNetworkTokens.supportedTokens.push({\n                contractAddress: eth.contractAddress\n              });\n            }\n\n            inputToken = supportedNetworkTokens.defaultInputToken || eth.contractAddress;\n            _a = this;\n            return [4\n            /*yield*/\n            , this._tokenService.getTokenInformation(inputToken, this._context.ethereumProvider)];\n\n          case 2:\n            _a.inputToken = _d.sent();\n            this.inputToken$.next(this.inputToken);\n            return [4\n            /*yield*/\n            , this.getBalances()];\n\n          case 3:\n            _d.sent();\n\n            this._blockStream = this.subscribeToBlockStream();\n\n            this._theming.apply();\n\n            if (!supportedNetworkTokens.defaultOutputToken) return [3\n            /*break*/\n            , 5];\n            return [4\n            /*yield*/\n            , this.buildFactory(this.inputToken.contractAddress, supportedNetworkTokens.defaultOutputToken)];\n\n          case 4:\n            _d.sent();\n\n            return [3\n            /*break*/\n            , 7];\n\n          case 5:\n            _c = this;\n            return [4\n            /*yield*/\n            , this._tokenService.getTokenInformation(inputToken, this._context.ethereumProvider)];\n\n          case 6:\n            _c.inputToken = _d.sent();\n            this.inputToken$.next(this.inputToken);\n            _d.label = 7;\n\n          case 7:\n            if (this._inputAmount && this.inputToken && this.outputToken) {\n              this.buildFactory(this.inputToken.contractAddress, this.outputToken.contractAddress);\n            } // resync once got context so ordering of tokens\n            // can sync\n\n\n            this.getBalances();\n            this.loading$.next(false);\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Destroy logic\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.destroy = function () {\n    var _a;\n\n    this._quoteSubscription.unsubscribe();\n\n    this._blockStream.unsubscribe();\n\n    this._chainService.unwatch();\n\n    (_a = this.tradeContext) === null || _a === void 0 ? void 0 : _a.destroy();\n  };\n  /**\r\n   * Change ethereum address for your dApp if your provider does not\r\n   * emit the event `accountsChanged`\r\n   * @param ethereumAddress The ethereum address\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.changeEthereumAddress = function (ethereumAddress) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        this._quoteSubscription.unsubscribe();\n\n        this._ethereumProvider.updateEthereumAddress(ethereumAddress);\n\n        this.init();\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\r\n   * Change the chain for your dApp if your provider does not\r\n   * emit the event `chainChanged`. Your ethereum provider you passed\r\n   * to the lib if changed will work without passing a `newEthereumProvider`\r\n   * if its a brand new instance you need to pass the lib the new ethereum provider\r\n   * @param newEthereumProvider The new ethereum provider\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.changeChain = function (newEthereumProvider) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        if (newEthereumProvider) {\n          this._context.ethereumProvider = newEthereumProvider;\n        }\n\n        this._ethereumProvider = new ethereum_provider_1.EthereumProvider(this._context.ethereumAddress, this._context.ethereumProvider);\n        this._chainService = new chain_1.ChainService(this._ethereumProvider);\n        this._tokenService = new token_1.TokenService(this._ethereumProvider, this._context.supportedNetworkTokens);\n\n        this._quoteSubscription.unsubscribe();\n\n        this.init();\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\r\n   * Setup ethereum context\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.setupEthereumContext = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a;\n\n      var _this = this;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _a = this;\n            return [4\n            /*yield*/\n            , this._ethereumProvider.provider.getNetwork()];\n\n          case 1:\n            _a.chainId = _c.sent().chainId;\n            this.chainId$.next(this.chainId);\n            this.supportedNetwork = this._ethereumProvider.isSupportedChain(this.chainId, this._context.supportedNetworkTokens);\n            this.supportedNetwork$.next(this.supportedNetwork);\n\n            if (this.supportedNetwork) {\n              this._tokensFactoryPublic = new simple_uniswap_sdk_1.TokensFactoryPublic({\n                chainId: this.chainId\n              });\n            } // handle chain and account changes automatically\n            // if they have event handlers on\n\n\n            if (this._context.ethereumProvider.on) {\n              this._context.ethereumProvider.on('accountsChanged', function (accounts) {\n                return __awaiter(_this, void 0, void 0, function () {\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        return [4\n                        /*yield*/\n                        , this.changeEthereumAddress(accounts[0])];\n\n                      case 1:\n                        _a.sent();\n\n                        return [2\n                        /*return*/\n                        ];\n                    }\n                  });\n                });\n              });\n\n              this._context.ethereumProvider.on('chainChanged', function () {\n                return __awaiter(_this, void 0, void 0, function () {\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        return [4\n                        /*yield*/\n                        , this.changeChain()];\n\n                      case 1:\n                        _a.sent();\n\n                        return [2\n                        /*return*/\n                        ];\n                    }\n                  });\n                });\n              });\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Send the approve allowance\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.approveAllowance = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this._theming.hideSettings();\n\n            this.miningTransaction = {\n              status: models_1.TransactionStatus.waitingForConfirmation,\n              miningAction: models_1.MiningAction.approval\n            };\n            this.miningTransaction$.next(this.miningTransaction);\n            return [4\n            /*yield*/\n            , this.handleTransaction(this.tradeContext.approvalTransaction, this.miningTransaction)];\n\n          case 1:\n            _a.sent();\n\n            if (this.miningTransaction.status === models_1.TransactionStatus.completed) {\n              this.miningTransaction = undefined;\n              this.miningTransaction$.next(this.miningTransaction);\n              this.tradeContext.approvalTransaction = undefined;\n              this.tradeContext.hasEnoughAllowance = true;\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Send the swap transaction\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.swapTransaction = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.miningTransaction = {\n              status: models_1.TransactionStatus.waitingForConfirmation,\n              miningAction: models_1.MiningAction.swap\n            };\n            this.miningTransaction$.next(this.miningTransaction);\n            this.showTransaction();\n            return [4\n            /*yield*/\n            , this.handleTransaction(this.tradeContext.transaction, this.miningTransaction)];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Toggle showing and hiding the settings\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.toggleSettings = function () {\n    if (!this.transactionInProcess()) {\n      this._theming.toggleSettings();\n    }\n  };\n  /**\r\n   * Open token selector from\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.openTokenSelectorFrom = function () {\n    this._theming.showTokenSelector();\n\n    this.selectorOpenFrom = models_1.SelectTokenActionFrom.input;\n    this.selectorOpenFrom$.next(this.selectorOpenFrom);\n  };\n  /**\r\n   * Open token selector to\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.openTokenSelectorTo = function () {\n    this._theming.showTokenSelector();\n\n    this.selectorOpenFrom = models_1.SelectTokenActionFrom.output;\n    this.selectorOpenFrom$.next(this.selectorOpenFrom);\n  };\n  /**\r\n   * Hide the token selector\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.hideTokenSelector = function () {\n    this.selectorOpenFrom = undefined;\n    this.currentTokenSearch = undefined;\n\n    this._theming.hideTokenSelector();\n  };\n  /**\r\n   * Show the confirm swap modal\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.showConfirmSwap = function () {\n    this._theming.showConfirmSwap();\n\n    this._confirmSwapOpened = true;\n  };\n  /**\r\n   * Hide the confirm swap modal\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.hideConfirmSwap = function () {\n    this._theming.hideConfirmSwap();\n\n    this._confirmSwapOpened = false;\n    this.acceptPriceChange();\n  };\n  /**\r\n   * Show transaction modal\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.showTransaction = function () {\n    this._theming.hideConfirmSwap();\n\n    this._theming.showTransaction();\n  };\n  /**\r\n   * Hide the transaction modal\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.hideTransaction = function () {\n    var _a;\n\n    this._theming.hideTransaction();\n\n    this.miningTransaction = undefined;\n    this.miningTransaction$.next(this.miningTransaction);\n    (_a = this.tradeContext) === null || _a === void 0 ? void 0 : _a.destroy();\n    this.tradeContext = undefined;\n    this.tradeContext$.next(undefined);\n    this._inputAmount = new bignumber_js_1.BigNumber(0); // let the client know the swap all done to clear down the fields\n\n    this.tradeCompleted$.next(true);\n    this.tradeCompleted$.next(false);\n    this.hideConfirmSwap();\n  };\n  /**\r\n   * Change token selected\r\n   * @param contractAddress The contract address\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.changeToken = function (contractAddress) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _a = this.selectorOpenFrom;\n\n            switch (_a) {\n              case models_1.SelectTokenActionFrom.input:\n                return [3\n                /*break*/\n                , 1];\n\n              case models_1.SelectTokenActionFrom.output:\n                return [3\n                /*break*/\n                , 3];\n            }\n\n            return [3\n            /*break*/\n            , 5];\n\n          case 1:\n            return [4\n            /*yield*/\n            , this.changeInputToken(contractAddress)];\n\n          case 2:\n            _c.sent();\n\n            return [2\n            /*return*/\n            ];\n\n          case 3:\n            return [4\n            /*yield*/\n            , this.changeOutputToken(contractAddress)];\n\n          case 4:\n            _c.sent();\n\n            _c.label = 5;\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Change trade price\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.changeTradePrice = function (amount, directon) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (directon === simple_uniswap_sdk_1.TradeDirection.input) {\n              this._inputAmount = new bignumber_js_1.BigNumber(amount);\n            }\n\n            if (!!this.factory) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.buildFactory(this.inputToken.contractAddress, this.outputToken.contractAddress)];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            return [4\n            /*yield*/\n            , this.trade(new bignumber_js_1.BigNumber(amount), directon)];\n\n          case 3:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Set max input\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.setMaxInput = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var maxBalance;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            maxBalance = this.inputToken.balance.toFixed();\n            return [4\n            /*yield*/\n            , this.changeTradePrice(maxBalance, simple_uniswap_sdk_1.TradeDirection.input)];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , maxBalance];\n        }\n      });\n    });\n  };\n  /**\r\n   * Swap switch\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.swapSwitch = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var clonedOutput, clonedInput, amount, amount;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            clonedOutput = utils_1.Utils.deepClone(this.outputToken);\n            clonedInput = utils_1.Utils.deepClone(this.inputToken);\n            return [4\n            /*yield*/\n            , this.buildFactory(clonedOutput.contractAddress, clonedInput.contractAddress, false)];\n\n          case 1:\n            _a.sent();\n\n            if (!this.tradeContext) return [3\n            /*break*/\n            , 6];\n            if (!(this.tradeContext.quoteDirection === simple_uniswap_sdk_1.TradeDirection.output)) return [3\n            /*break*/\n            , 3];\n            amount = utils_1.Utils.deepClone(this.tradeContext.baseConvertRequest);\n            return [4\n            /*yield*/\n            , this.trade(new bignumber_js_1.BigNumber(amount), simple_uniswap_sdk_1.TradeDirection.input)];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , {\n              outputValue: this.tradeContext.expectedConvertQuote,\n              inputValue: amount\n            }];\n\n          case 3:\n            amount = utils_1.Utils.deepClone(this.tradeContext.baseConvertRequest);\n            return [4\n            /*yield*/\n            , this.trade(new bignumber_js_1.BigNumber(amount), simple_uniswap_sdk_1.TradeDirection.output)];\n\n          case 4:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , {\n              outputValue: amount,\n              inputValue: this.tradeContext.expectedConvertQuote\n            }];\n\n          case 5:\n            return [3\n            /*break*/\n            , 7];\n\n          case 6:\n            return [2\n            /*return*/\n            , {\n              outputValue: '',\n              inputValue: ''\n            }];\n\n          case 7:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Accept the price change\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.acceptPriceChange = function () {\n    if (this.newPriceTradeContext) {\n      this.tradeContext = this.newPriceTradeContext;\n      this.tradeContext$.next(this.tradeContext);\n    }\n\n    this.newPriceTradeContext = undefined;\n    this.newPriceTradeContext$.next(undefined);\n  };\n  /**\r\n   * work out what 1 is equal to\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.workOutOneEqualTo = function () {\n    return utils_1.Utils.toPrecision(new bignumber_js_1.BigNumber(+this.tradeContext.expectedConvertQuote / +this.tradeContext.baseConvertRequest));\n  };\n  /**\r\n   * Set multihops\r\n   * @param disableMultihops The status of disable multihops\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.setDisableMultihops = function (disableMultihops) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (disableMultihops === this.uniswapPairSettings.disableMultihops) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            this.uniswapPairSettings.disableMultihops = disableMultihops;\n            this.uniswapPairSettings$.next(this.uniswapPairSettings);\n            return [4\n            /*yield*/\n            , this.buildFactory(this.inputToken.contractAddress, this.outputToken.contractAddress, false)];\n\n          case 1:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this.executeTradeAndHonourLastTradeDirection()];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Set transaction deadline\r\n   * @param deadlineMinutes The deadline minutes the tx has to be mined before it fails\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.setTransactionDeadline = function (deadlineMinutes) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (Number(deadlineMinutes) === this.uniswapPairSettings.deadlineMinutes) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            if (deadlineMinutes === '') {\n              this.uniswapPairSettings.deadlineMinutes = 20;\n            } else {\n              this.uniswapPairSettings.deadlineMinutes = Number(deadlineMinutes);\n            }\n\n            this.uniswapPairSettings$.next(this.uniswapPairSettings);\n            return [4\n            /*yield*/\n            , this.buildFactory(this.inputToken.contractAddress, this.outputToken.contractAddress, false)];\n\n          case 1:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this.executeTradeAndHonourLastTradeDirection()];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Set transaction slippage\r\n   * @param slippage The slippage the route can take\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.setSlippage = function (slippage) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (Number(slippage) / 100 === this.uniswapPairSettings.slippage) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            if (slippage === '') {\n              this.uniswapPairSettings.slippage = 0.005;\n            } else {\n              this.uniswapPairSettings.slippage = Number(slippage) / 100;\n            }\n\n            this.uniswapPairSettings$.next(this.uniswapPairSettings);\n            return [4\n            /*yield*/\n            , this.buildFactory(this.inputToken.contractAddress, this.outputToken.contractAddress, false)];\n\n          case 1:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this.executeTradeAndHonourLastTradeDirection()];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Search for tokens\r\n   * @param search The search term\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.searchToken = function (search) {\n    this.currentTokenSearch = search;\n    this.supportedTokenBalances = this._tokenService.searchToken(search, this.supportedTokenBalances);\n    return this.supportedTokenBalances;\n  };\n  /**\r\n   * See if the transaction is in process\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.transactionInProcess = function () {\n    var _a, _c;\n\n    return ((_a = this.miningTransaction) === null || _a === void 0 ? void 0 : _a.status) === models_1.TransactionStatus.waitingForConfirmation || ((_c = this.miningTransaction) === null || _c === void 0 ? void 0 : _c.status) === models_1.TransactionStatus.mining;\n  };\n  /**\r\n   * View the tx on etherscan\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.viewOnEtherscan = function () {\n    var _a;\n\n    if ((_a = this.miningTransaction) === null || _a === void 0 ? void 0 : _a.blockExplorerLink) {\n      window.open(this.miningTransaction.blockExplorerLink, '_blank');\n    }\n  };\n  /**\r\n   * Execute the trade but honour the last trade direction\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.executeTradeAndHonourLastTradeDirection = function () {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            if (!(((_a = this.tradeContext) === null || _a === void 0 ? void 0 : _a.quoteDirection) === simple_uniswap_sdk_1.TradeDirection.output)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.trade(new bignumber_js_1.BigNumber(utils_1.Utils.deepClone(this.tradeContext.baseConvertRequest)), simple_uniswap_sdk_1.TradeDirection.output)];\n\n          case 1:\n            _c.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            return [4\n            /*yield*/\n            , this.trade(this._inputAmount, simple_uniswap_sdk_1.TradeDirection.input)];\n\n          case 3:\n            _c.sent();\n\n            _c.label = 4;\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Handle transaction\r\n   * @param transaction The transaction\r\n   * @param miningTransaction The mining transaction\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.handleTransaction = function (transaction, miningTransaction) {\n    return __awaiter(this, void 0, void 0, function () {\n      var txHash_1, blockStream_1, error_1;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this._ethereumProvider.sendAsync(transaction)];\n\n          case 1:\n            txHash_1 = _a.sent();\n\n            this._quoteSubscription.unsubscribe();\n\n            miningTransaction.status = models_1.TransactionStatus.mining;\n            miningTransaction.txHash = txHash_1;\n            miningTransaction.blockExplorerLink = this._chainService.getBlockExplorerLinkForTransactionHash(this.chainId, txHash_1);\n            this.miningTransaction$.next(miningTransaction);\n            blockStream_1 = rxjs_1.Subscription.EMPTY;\n            return [4\n            /*yield*/\n            , new Promise(function (resolve, reject) {\n              blockStream_1 = _this._chainService.newBlock$.subscribe(function () {\n                return __awaiter(_this, void 0, void 0, function () {\n                  var receipt, error_2;\n                  return __generator(this, function (_a) {\n                    switch (_a.label) {\n                      case 0:\n                        _a.trys.push([0, 2,, 3]);\n\n                        return [4\n                        /*yield*/\n                        , this._ethereumProvider.provider.getTransactionReceipt(txHash_1)];\n\n                      case 1:\n                        receipt = _a.sent();\n\n                        if (receipt) {\n                          resolve();\n                          this.miningTransaction.status = models_1.TransactionStatus.completed;\n                          this.miningTransaction$.next(miningTransaction);\n                        }\n\n                        return [3\n                        /*break*/\n                        , 3];\n\n                      case 2:\n                        error_2 = _a.sent();\n                        blockStream_1.unsubscribe();\n                        reject(error_2);\n                        return [3\n                        /*break*/\n                        , 3];\n\n                      case 3:\n                        return [2\n                        /*return*/\n                        ];\n                    }\n                  });\n                });\n              });\n            })];\n\n          case 2:\n            _a.sent();\n\n            blockStream_1.unsubscribe();\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            error_1 = _a.sent();\n            miningTransaction.status = models_1.TransactionStatus.rejected;\n            this.miningTransaction$.next(miningTransaction);\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Change input token\r\n   * @param contractAddress The contract address\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.changeInputToken = function (contractAddress) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.changeTokenHandler(contractAddress, this.outputToken.contractAddress)];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Change output token\r\n   * @param contractAddress The contract address\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.changeOutputToken = function (contractAddress) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.changeTokenHandler(this.inputToken.contractAddress, contractAddress)];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Change token handler\r\n   * @param inputToken The input token\r\n   * @param outputToken The output token\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.changeTokenHandler = function (inputToken, outputToken) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.hideTokenSelector();\n            return [4\n            /*yield*/\n            , this.buildFactory(inputToken, outputToken, false)];\n\n          case 1:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this.executeTradeAndHonourLastTradeDirection()];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Build factory\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.buildFactory = function (inputToken, outputToken, executeTrade) {\n    var _a;\n\n    if (executeTrade === void 0) {\n      executeTrade = true;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var uniswapPair, _c, fiatPrices, _d, _e, _f, _g, _h, _j, _k, _l;\n\n      return __generator(this, function (_m) {\n        switch (_m.label) {\n          case 0:\n            (_a = this.tradeContext) === null || _a === void 0 ? void 0 : _a.destroy();\n            inputToken = simple_uniswap_sdk_1.getAddress(inputToken, true);\n            outputToken = simple_uniswap_sdk_1.getAddress(outputToken, true);\n            uniswapPair = this.createUniswapPairContext(inputToken, outputToken, this.uniswapPairSettings);\n            _c = this;\n            return [4\n            /*yield*/\n            , uniswapPair.createFactory()];\n\n          case 1:\n            _c.factory = _m.sent();\n            return [4\n            /*yield*/\n            , this._coinGecko.getCoinGeckoFiatPrices([this.factory.fromToken.contractAddress, this.factory.toToken.contractAddress], this.chainId)];\n\n          case 2:\n            fiatPrices = _m.sent();\n            _d = this;\n            _f = (_e = this._tokenService).buildExtendedToken;\n            _g = [this.factory.fromToken];\n            return [4\n            /*yield*/\n            , this.factory.getFromTokenBalance()];\n\n          case 3:\n            return [4\n            /*yield*/\n            , _f.apply(_e, _g.concat([_m.sent(), fiatPrices]))];\n\n          case 4:\n            _d.inputToken = _m.sent();\n            this.inputToken$.next(this.inputToken);\n            _h = this;\n            _k = (_j = this._tokenService).buildExtendedToken;\n            _l = [this.factory.toToken];\n            return [4\n            /*yield*/\n            , this.factory.getToTokenBalance()];\n\n          case 5:\n            return [4\n            /*yield*/\n            , _k.apply(_j, _l.concat([_m.sent(), fiatPrices]))];\n\n          case 6:\n            _h.outputToken = _m.sent();\n            this.outputToken$.next(this.outputToken);\n            if (!executeTrade) return [3\n            /*break*/\n            , 8];\n            return [4\n            /*yield*/\n            , this.trade(this._inputAmount, simple_uniswap_sdk_1.TradeDirection.input)];\n\n          case 7:\n            _m.sent();\n\n            _m.label = 8;\n\n          case 8:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Create uniswap pair context\r\n   * @param inputToken The input token\r\n   * @param outputToken The output token\r\n   * @param settings The settings\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.createUniswapPairContext = function (inputToken, outputToken, settings) {\n    if (this._context.ethereumProvider) {\n      return new simple_uniswap_sdk_1.UniswapPair({\n        fromTokenContractAddress: inputToken,\n        toTokenContractAddress: outputToken,\n        ethereumAddress: this._ethereumProvider.address,\n        ethereumProvider: this._context.ethereumProvider,\n        settings: settings\n      });\n    }\n\n    return new simple_uniswap_sdk_1.UniswapPair({\n      fromTokenContractAddress: inputToken,\n      toTokenContractAddress: outputToken,\n      ethereumAddress: this._ethereumProvider.address,\n      chainId: this.chainId,\n      ethereumProvider: this._ethereumProvider.provider,\n      settings: settings\n    });\n  };\n  /**\r\n   * Execute the trade quote\r\n   * @param amount The amount\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.trade = function (amount, direction) {\n    return __awaiter(this, void 0, void 0, function () {\n      var context;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!amount.isGreaterThan(0)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.factory.trade(amount.toFixed(), direction)];\n\n          case 1:\n            context = _a.sent();\n            this.tradeContext = this.formatTradeContext(context);\n            this.tradeContext$.next(this.tradeContext);\n            this._quoteSubscription = this.tradeContext.quoteChanged$.subscribe(function (quote) {\n              var _a, _c, _d;\n\n              if (((_a = _this.miningTransaction) === null || _a === void 0 ? void 0 : _a.miningAction) === models_1.MiningAction.swap && (((_c = _this.miningTransaction) === null || _c === void 0 ? void 0 : _c.status) === models_1.TransactionStatus.mining || ((_d = _this.miningTransaction) === null || _d === void 0 ? void 0 : _d.status) === models_1.TransactionStatus.completed)) {\n                _this._quoteSubscription.unsubscribe();\n\n                return;\n              }\n\n              var formattedQuote = _this.formatTradeContext(quote);\n\n              if (_this._confirmSwapOpened) {\n                _this.newPriceTradeContext = formattedQuote;\n\n                _this.newPriceTradeContext$.next(_this.newPriceTradeContext);\n              } else {\n                _this.tradeContext = formattedQuote;\n\n                _this.tradeContext$.next(_this.tradeContext);\n              }\n            });\n\n            if (this.tradeContext.quoteDirection === simple_uniswap_sdk_1.TradeDirection.output) {\n              this._inputAmount = new bignumber_js_1.BigNumber(utils_1.Utils.deepClone(this.tradeContext.expectedConvertQuote));\n            }\n\n            _a.label = 2;\n\n          case 2:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Format trade context values\r\n   * @param context The context\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.formatTradeContext = function (context) {\n    context.liquidityProviderFee = utils_1.Utils.toPrecision(context.liquidityProviderFee);\n\n    if (context.minAmountConvertQuote) {\n      context.minAmountConvertQuote = utils_1.Utils.toPrecision(context.minAmountConvertQuote);\n    }\n\n    if (context.maximumSent) {\n      context.maximumSent = utils_1.Utils.toPrecision(context.maximumSent);\n    }\n\n    context.expectedConvertQuote = utils_1.Utils.toPrecision(context.expectedConvertQuote);\n    return context;\n  };\n  /**\r\n   * Subscribe to the block stream\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.subscribeToBlockStream = function () {\n    var _this = this;\n\n    return this._chainService.newBlock$.subscribe(function (block) {\n      _this.blockNumber = block;\n\n      _this.getBalances();\n    });\n  };\n  /**\r\n   * Get the balances of the supported contracts\r\n   */\n\n\n  UniswapDappSharedLogic.prototype.getBalances = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var tokenWithAllowanceInfo, fiatPrices_1, _a, inputToken, newInputBalance, newInputFiatPrice, outputToken, newOutputBalance, newOutputFiatPrice;\n\n      var _this = this;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            if (!this.supportedNetwork) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , this._tokensFactoryPublic.getAllowanceAndBalanceOfForContracts(this._ethereumProvider.address, this._context.supportedNetworkTokens.find(function (t) {\n              return t.chainId === _this.chainId;\n            }).supportedTokens.map(function (c) {\n              return simple_uniswap_sdk_1.getAddress(c.contractAddress, true);\n            }), true)];\n\n          case 1:\n            tokenWithAllowanceInfo = _c.sent();\n            return [4\n            /*yield*/\n            , this._coinGecko.getCoinGeckoFiatPrices(tokenWithAllowanceInfo.map(function (c) {\n              return c.token.contractAddress;\n            }), this.chainId)];\n\n          case 2:\n            fiatPrices_1 = _c.sent();\n            _a = this;\n            return [4\n            /*yield*/\n            , Promise.all(tokenWithAllowanceInfo.map(function (item) {\n              return __awaiter(_this, void 0, void 0, function () {\n                var token, canShow;\n\n                var _a;\n\n                return __generator(this, function (_c) {\n                  switch (_c.label) {\n                    case 0:\n                      return [4\n                      /*yield*/\n                      , this._tokenService.buildExtendedToken(item.token, item.allowanceAndBalanceOf.balanceOf, fiatPrices_1)];\n\n                    case 1:\n                      token = _c.sent();\n                      canShow = true;\n\n                      if (this.currentTokenSearch) {\n                        canShow = this.supportedTokenBalances.find(function (c) {\n                          return c.contractAddress.toLowerCase() === item.token.contractAddress.toLowerCase();\n                        }).canShow;\n                      }\n\n                      _a = {\n                        chainId: token.chainId,\n                        contractAddress: token.contractAddress,\n                        decimals: token.decimals,\n                        symbol: token.symbol,\n                        name: token.name,\n                        fiatPrice: token.fiatPrice,\n                        balance: token.balance,\n                        canShow: canShow\n                      };\n                      return [4\n                      /*yield*/\n                      , this._tokenService.getTokenImage(token.contractAddress, token.chainId)];\n\n                    case 2:\n                      return [2\n                      /*return*/\n                      , (_a.tokenImageContext = _c.sent(), _a)];\n                  }\n                });\n              });\n            }))];\n\n          case 3:\n            _a.supportedTokenBalances = _c.sent().sort(function (a, b) {\n              if (a.name < b.name) {\n                return -1;\n              }\n\n              if (a.name > b.name) {\n                return 1;\n              }\n\n              return 0;\n            }).sort(function (a, b) {\n              if (a.balance.isLessThan(b.balance)) {\n                return 1;\n              }\n\n              if (a.balance.isGreaterThan(b.balance)) {\n                return -1;\n              }\n\n              return 0;\n            }).sort(function (a, _b) {\n              var _a;\n\n              if (a.contractAddress === _this.inputToken.contractAddress) {\n                return -1;\n              }\n\n              if (a.contractAddress === ((_a = _this.outputToken) === null || _a === void 0 ? void 0 : _a.contractAddress)) {\n                return -1;\n              }\n\n              return 0;\n            });\n            inputToken = this.supportedTokenBalances.find(function (c) {\n              return c.contractAddress === _this.inputToken.contractAddress;\n            });\n\n            if (inputToken) {\n              newInputBalance = inputToken.balance;\n              newInputFiatPrice = inputToken.fiatPrice;\n\n              if (!this.inputToken.balance.isEqualTo(newInputBalance) || newInputFiatPrice && this.inputToken.fiatPrice && !this.inputToken.fiatPrice.isEqualTo(newInputFiatPrice)) {\n                this.inputToken.balance = newInputBalance;\n                this.inputToken.fiatPrice = newInputFiatPrice;\n                this.inputToken$.next(this.inputToken);\n              }\n            }\n\n            if (this.outputToken) {\n              outputToken = this.supportedTokenBalances.find(function (c) {\n                return c.contractAddress === _this.outputToken.contractAddress;\n              });\n\n              if (outputToken) {\n                newOutputBalance = outputToken.balance;\n                newOutputFiatPrice = outputToken.fiatPrice;\n\n                if (!this.outputToken.balance.isEqualTo(newOutputBalance) || newOutputFiatPrice && this.outputToken.fiatPrice && !this.outputToken.fiatPrice.isEqualTo(newOutputFiatPrice)) {\n                  this.outputToken.balance = newOutputBalance;\n                  this.outputToken.fiatPrice = newOutputFiatPrice;\n                  this.outputToken$.next(this.outputToken);\n                }\n              }\n            }\n\n            return [3\n            /*break*/\n            , 5];\n\n          case 4:\n            this.supportedTokenBalances = [];\n            _c.label = 5;\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return UniswapDappSharedLogic;\n}();\n\nexports.UniswapDappSharedLogic = UniswapDappSharedLogic;","map":null,"metadata":{},"sourceType":"script"}