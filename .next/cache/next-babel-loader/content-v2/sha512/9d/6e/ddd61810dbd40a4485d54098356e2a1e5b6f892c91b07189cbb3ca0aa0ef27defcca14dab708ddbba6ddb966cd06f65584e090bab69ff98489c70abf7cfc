{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport { getStepsModalCurrentStep } from '../../../store/ui/selectors';\nimport { BaseStepModal } from './base_step_modal';\nimport { ethers, utils } from 'ethers';\nimport { initBalances, stepsModalAdvanceStep, swapTokens } from '../../../store/actions';\nimport { getWeb3Wrapper } from '../../../services/web3_wrapper';\nimport { retrieveError } from '../../../util/gsn_error_handler';\nimport { getRelayHubContract } from '../../../services/relay_hub_service';\n\nclass SwapTokensStep extends React.Component {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"state\", {\n      error: \"\"\n    });\n\n    _defineProperty(this, \"render\", () => {\n      const {\n        error\n      } = this.state;\n      const {\n        buildStepsProgress,\n        step\n      } = this.props;\n      const {\n        amount,\n        token\n      } = step;\n      const title = `Swap ${amount} ${token.symbol}`;\n      const confirmCaption = `Confirm on Metamask to swap tokens`;\n      const loadingCaption = \"Swapping Tokens\";\n      const doneCaption = \"Tokens Swapped\";\n      const errorCaption = `Failed to swap tokens: ${error}`;\n      const loadingFooterCaption = `Waiting for confirmation...`;\n      const doneFooterCaption = `Tokens Swapped`;\n      return /*#__PURE__*/_jsx(BaseStepModal, {\n        step: step,\n        title: title,\n        confirmCaption: confirmCaption,\n        loadingCaption: loadingCaption,\n        doneCaption: doneCaption,\n        errorCaption: errorCaption,\n        loadingFooterCaption: loadingFooterCaption,\n        doneFooterCaption: doneFooterCaption,\n        buildStepsProgress: buildStepsProgress,\n        estimatedTxTimeMs: 30000,\n        runAction: this._approveTokens,\n        showPartialProgress: true\n      });\n    });\n\n    _defineProperty(this, \"_approveTokens\", async ({\n      onLoading,\n      onDone,\n      onError\n    }) => {\n      const {\n        step,\n        onTokensSwap\n      } = this.props;\n      const web3Wrapper = await getWeb3Wrapper();\n\n      try {\n        const contractTransaction = await onTokensSwap(step.token, step.amount);\n        onLoading();\n        const contractReceipt = await contractTransaction.wait();\n        const txHash = contractReceipt.logs[0].transactionHash;\n        const tx = await web3Wrapper.waitForTransaction(txHash);\n        const relayHub = await getRelayHubContract(web3Wrapper.getSigner());\n        let deposited;\n        let withdrawn;\n        tx.logs.map(log => {\n          try {\n            const parsedLog = relayHub.interface.parseLog(log);\n\n            if (parsedLog.name === \"Deposited\") {\n              deposited = utils.formatEther(parsedLog.args.amount);\n            } else if (parsedLog.name === \"Withdrawn\") {\n              withdrawn = utils.formatEther(parsedLog.args.amount);\n            }\n          } catch (e) {}\n        });\n        step.callback({\n          data: {\n            gasUsed: tx.gasUsed.toString(),\n            txHash,\n            txPrice: ethers.utils.formatEther(tx.gasUsed.mul(tx.effectiveGasPrice)),\n            deposited,\n            withdrawn\n          },\n          error: false\n        });\n        initBalances();\n        onDone();\n      } catch (e) {\n        const error = retrieveError(e.message);\n        step.callback({\n          error: true,\n          data: null,\n          message: error\n        });\n        initBalances();\n        this.setState({\n          error\n        });\n        onError(error);\n      }\n    });\n  }\n\n}\n\nconst mapStateToProps = state => {\n  return {\n    step: getStepsModalCurrentStep(state)\n  };\n};\n\nconst mapDispatchToProps = dispatch => {\n  return {\n    onTokensSwap: (token, amount) => dispatch(swapTokens(token, amount)),\n    advanceStep: () => dispatch(stepsModalAdvanceStep()),\n    initBalances: () => dispatch(initBalances())\n  };\n};\n\nconst SwapTokensStepContainer = connect(mapStateToProps, mapDispatchToProps)(SwapTokensStep);\nexport { SwapTokensStep, SwapTokensStepContainer };","map":null,"metadata":{},"sourceType":"module"}