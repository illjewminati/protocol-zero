// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../../interfaces/ISTN721.sol";
import "./ERC721Ownable.sol";

contract STN721 is ERC721Ownable, ISTN721 {

    address private parentAddress;
    uint256 private parentId; 

    /** @dev mapping(tokenId => isDivisible) */
    mapping(uint256 => bool) private _isDivisible;

    /** @dev in the for of mapping(tokenId => erc721ChildAddress) */
    mapping(uint256 => address) private _childIndexById;

    /** @dev in the for of mapping(erc721ChildAddress => tokenId) */
    mapping(address => uint256) private _childIndexByAddress;

    constructor(address _parentAddress, uint256 _parentId, string memory name, string memory symbol) ERC721Ownable(name, symbol) {
        parentAddress = _parentAddress;
        parentId = _parentId;
    }

    /** @dev attaches a stn721 contract to an tokenId */
    function attachChild(address stn721Child, uint256 tokenId) external virtual override onlyOwner returns(bool) {
        require(_isDivisible[tokenId], "Id is not divisible");
        require(stn721Child != address(0), "Contract child cannot be 0");
        require(ERC721Ownable(stn721Child).owner() == owner(), "Child owner is not owner");
        require(_childIndexById[tokenId] == address(0), "Id already attached");
        require(_childIndexByAddress[stn721Child] == 0, "Child already attached");
        _childIndexById[tokenId] = stn721Child;
        _childIndexByAddress[stn721Child] = tokenId;
        emit ChildAttached(stn721Child, tokenId); 
        return true;
        
    }

    function mint(bool divisible, uint256[] memory tokenIds, address receiver) external virtual override onlyOwner {
        /** @dev change it to assembly */
        for(uint256 i = 0; i < tokenIds.length; i++) {
            uint256 tokenId = tokenIds[i];
            _safeMint(receiver, tokenId);
            if(divisible) {
                _isDivisible[tokenId] = true; 
            }
        }
    }

    function getParentAddress() external virtual override view returns(address) {
        return parentAddress;
    } 

    function getParentId() external virtual override view returns(uint256) {
        return parentId;
    }

    function isDivisible(uint256 tokenId) external virtual override view returns(bool) {
        return _isDivisible[tokenId];
    } 

    function getChildIndexById(uint256 tokenId) external virtual override view returns(address) {
        return _childIndexById[tokenId];
    } 

    function getChildIndexByAddress(address stn721) external virtual override view returns(uint256) {
        return _childIndexByAddress[stn721]; 
    } 

}