// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/Ownable.sol";
import "../Permissions.sol"; 
import "../STN/STN721Manager.sol";
import "../../interfaces/IProduce.sol";

contract Produce is IProduce, Ownable {

    Permissions private permissions;
    STN721Manager private stn721Manager;

    ///@dev entry => Validation[]
    mapping(uint256 => Validation[]) private validations;
 
    ///@dev signatorie => (entry => hasVerified);
    mapping(address => mapping(uint256 => bool)) private verifiedEntry;

    ///@dev companyAddress => pos
    mapping(address => uint256[]) private entriesByCompany;

    ///@dev userAddress => pos
    mapping(address => uint256[]) private entriesByUser;

    ///@dev entry => EntryType
    mapping(uint256 => ProduceData) private dataByEntry;

    uint256 private pos = 0;


    constructor (address _multisigWallet, address _permissions) {
        require(_multisigWallet != address(0), "Multisig address cannot be 0");
        require(_permissions != address(0), "Permissions address cannot be 0");
        permissions = Permissions(_permissions);
        transferOwnership(_multisigWallet);
    }

     /** Setters */
    function setPermissionsContract(address _permissions) virtual override external onlyOwner {
        require(_permissions != address(0), "Permissions address cannot be 0");
        permissions = Permissions(_permissions);
        emit SetPermissionsContract(_permissions);
    }

    function setSTN721ManagerContract(address _stn721Manager) virtual override external onlyOwner {
        require(_stn721Manager != address(0), "Manager address cannot be 0");
        stn721Manager = STN721Manager(_stn721Manager);
        emit SetSTN721ManagerContract(_stn721Manager);
    }

    function produce(
        uint256[] calldata _tokenIds, 
        bool _divisible,
        address _stn721Address, 
        address _companyAddress,
        address[] calldata _involvedCompanies,
        bytes32 _dbId
    ) virtual override  external {
        require(_companyAddress != address(0), "Company address cannot be 0");
        bool hasPermission = permissions.getPermission(0, _companyAddress, _stn721Address, _msgSender());
        require(hasPermission, "Not authorized");
        require(_tokenIds.length > 0, "No uids provided");
        address[] memory involvedCompanies = new address[](_involvedCompanies.length + 1);
        involvedCompanies = _involvedCompanies;
        involvedCompanies[_involvedCompanies.length] = _companyAddress;
        stn721Manager.mint(_stn721Address, _divisible, _tokenIds, _companyAddress);
        _saveEvent(_companyAddress, _stn721Address, _tokenIds, involvedCompanies, _dbId);
    }

    /** @dev tokens minted go to owner of token */
    function produceChild(
        uint256[] calldata _tokenIds, 
        bool _divisible,
        address _stn721Address, 
        address _companyAddress,
        address[] calldata _involvedCompanies,
        bytes32 _dbId
    ) virtual override  external {
        require(_companyAddress != address(0), "Company address cannot be 0");
        bool hasPermission = permissions.getPermission(0, _companyAddress, _stn721Address, _msgSender());
        require(hasPermission, "Not authorized");
        require(_tokenIds.length > 0, "No uids provided");
        address[] memory involvedCompanies = new address[](_involvedCompanies.length + 1);
        involvedCompanies = _involvedCompanies;
        involvedCompanies[_involvedCompanies.length] = _companyAddress;
        stn721Manager.mintChild(_stn721Address, _divisible, _tokenIds);
        _saveEvent(_companyAddress, _stn721Address, _tokenIds, involvedCompanies, _dbId);
    }

    function createSTN721Child(
        address _companyAddress,
        address _stn721Parent,
        uint256 _tokenId, 
        string memory _name,  
        string memory _symbol
    ) virtual override external {
        require(_companyAddress != address(0), "Company address cannot be 0");
        bool hasPermission = permissions.getPermission(0, _companyAddress, _stn721Parent, _msgSender());
        require(hasPermission, "Not authorized");
        stn721Manager.createChildSTN721(_stn721Parent, _tokenId, _name, _symbol);
        // address newChild = stn721Manager.createChildSTN721(_stn721Parent, _tokenId, _name, _symbol);
        //TODO: emit with newChild
    }

    function validateEntry(uint256 _entry, address _companyAddress) virtual override external {
        require(_companyAddress != address(0), "Company address cannot be 0");
        require(_entry >= 0, "entry must be greater than 0");
        require(!verifiedEntry[_msgSender()][_entry], "User has already signed");
        require(permissions.isSignerApproved(_companyAddress, _msgSender()), "Signer is not approved in company");
        ProduceData memory entry = dataByEntry[_entry];
        address[] memory involvedCompanies = entry.involvedCompanies;
        if(_indexOf(involvedCompanies, _companyAddress) >= 0) {
            validations[_entry].push(
                Validation({
                    company: _companyAddress, 
                    signatorie: _msgSender(),
                    timestamp: block.timestamp
                })
            );
            verifiedEntry[_msgSender()][_entry] = true;
       }
       emit ValidationEvent(_companyAddress, _entry); 
    }

    function _saveEvent(
        address _companyAddress, 
        address _stn721Address,
        uint256[] memory _tokenIds, 
        address[] memory _involvedCompanies,
        bytes32 _dbId
    ) private {
        pos = pos + 1;
        entriesByCompany[_companyAddress].push(pos);
        entriesByUser[_msgSender()].push(pos);
        dataByEntry[pos] = ProduceData({
            company: _companyAddress,
            signatorie: _msgSender(),
            stn721Address: _stn721Address,
            tokenIds: _tokenIds,
            timestamp: block.timestamp,
            involvedCompanies: _involvedCompanies,
            dbId: _dbId
        });
        emit ProductionEvent(_companyAddress, _stn721Address, _dbId, _tokenIds.length); 
    }

    /**Getters */
    function getEntriesByCompany(address _company) virtual override  external view returns(uint256[] memory) {
        return entriesByCompany[_company];
    }

    function getEntriesByUser(address _user) virtual override  external view returns(uint256[] memory) {
        return entriesByUser[_user];
    }

    function getEntryData(uint256 _pos) virtual override  external view returns(ProduceData memory) {
        return dataByEntry[_pos];
    }

    function getNumOfValidations(uint256 _entry) virtual override  external view returns (uint256) {
        return validations[_entry].length;
    }

    function getValidation(uint256 _entry, uint256 _pos) virtual override  external view returns (Validation memory) {
        return validations[_entry][_pos];
    }

    function _indexOf(address[] memory self, address value) private pure returns (int8) {
        for(uint8 i = 0; i <= self.length; i++) {
            if(self[i] == value) return int8(i);
        }
        return int8(-1);
    }
}